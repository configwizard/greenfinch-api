package main

import (
	"bytes"
	"context"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha512"
	_ "embed"
	"errors"
	"flag"
	"fmt"
	_ "github.com/configwizard/greenfinch-api/api/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/configwizard/greenfinch-api/api/objects"
	"github.com/configwizard/greenfinch-api/api/pkg/config"
	"github.com/configwizard/greenfinch-api/api/pkg/pool"
	"github.com/configwizard/greenfinch-api/api/pkg/tokens"
	wal "github.com/configwizard/greenfinch-api/api/pkg/wallet"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	"github.com/nspcc-dev/neo-go/cli/flags"
	"github.com/nspcc-dev/neo-go/pkg/crypto/keys"
	"github.com/nspcc-dev/neo-go/pkg/util"
	"github.com/nspcc-dev/neo-go/pkg/wallet"
	"log"
	"net/http"
	"os"
	"time"
)

const usage = `Example

$ ./uploadObjects -wallets ../sample_wallets/wallet.json
password is password
`


var (
	walletPath = flag.String("wallet", os.Getenv("WALLET_PATH"), "path to JSON wallets file")
	//walletAddr = flag.String("address", "", "wallets address [optional]")
	cnt = flag.Bool("container", false, "make a container")
	obj = flag.Bool("object", false, "upload an object")
	containerID = flag.String("containerID", "", "use a specific container to upload an object to")
	//createWallet = flag.Bool("create", false, "create a wallets")
	//useBearerToken = flag.Bool("bearer", false, "use a bearer token")
	configLocation = flag.String("password", os.Getenv("CONFIG_LOCATION"), "wallet password")
	password = flag.String("password", os.Getenv("WALLET_KEY"), "wallet password")
)

func GetCredentialsFromPath(path, address, password string) (*ecdsa.PrivateKey, error) {
	w, err := wallet.NewWalletFromFile(path)
	if err != nil {
		return nil, fmt.Errorf("can't read the wallets: %walletPath", err)
	}

	return getKeyFromWallet(w, address, password)
}
// getKeyFromWallet fetches private key from neo-go wallets structure
func getKeyFromWallet(w *wallet.Wallet, addrStr, password string) (*ecdsa.PrivateKey, error) {
	var (
		addr util.Uint160
		err  error
	)

	if addrStr == "" {
		addr = w.GetChangeAddress()
	} else {
		addr, err = flags.ParseAddress(addrStr)
		if err != nil {
			return nil, fmt.Errorf("invalid wallets address %s: %w", addrStr, err)
		}
	}

	acc := w.GetAccount(addr)
	if acc == nil {
		return nil, fmt.Errorf("invalid wallets address %s: %w", addrStr, err)
	}

	if err := acc.Decrypt(password, keys.NEP2ScryptParams()); err != nil {
		return nil, errors.New("[decrypt] invalid password - " + err.Error())

	}

	return &acc.PrivateKey().PrivateKey, nil
}

//func createProtectedContainer(ctx context.Context, cli *client.Client, id *owner.ID) (cid.ID, error) {
//	// Step 0: prepare credentials.
//	// There are two keys:
//	// - containerOwnerKey -- private key of the user, should be managed by wallet provider
//	// - requestSenderKey -- private key of the gateway app, which will do operation on behalf of the user
//
//	// Step 1: create container
//	containerPolicy, err := policy.Parse("REP 2")
//	if err != nil {
//		return cid.ID{}, err
//	}
//	cnr := container.New(
//		container.WithPolicy(containerPolicy),
//		container.WithOwnerID(id),
//		container.WithCustomBasicACL(acl.EACLPublicBasicRule),
//	)
//
//	var prmContainerPut client.PrmContainerPut
//	prmContainerPut.SetContainer(*cnr)
//
//	cnrResponse, err := cli.ContainerPut(ctx, prmContainerPut)
//	if err != nil {
//		return cid.ID{}, err
//	}
//	containerID := cnrResponse.ID()
//
//	await30Seconds(func() bool {
//		var prmContainerGet client.PrmContainerGet
//		prmContainerGet.SetContainer(*containerID)
//		_, err = cli.ContainerGet(ctx, prmContainerGet)
//		fmt.Println("await error", err)
//		return err == nil
//	})
//
//	fmt.Println("container ID", containerID.String())
//	return *containerID, nil
//}

//func setRestrictedContainerAccess(ctx context.Context, cli *client.Client, containerID cid.ID) error {
//
//	// Step 2: set restrictive extended ACL
//	table := tokens.PUTAllowDenyOthersEACL(containerID, nil)
//	var prmContainerSetEACL client.PrmContainerSetEACL
//	prmContainerSetEACL.SetTable(table)
//
//	_, err := cli.ContainerSetEACL(ctx, prmContainerSetEACL)
//	if err != nil {
//		return err
//	}
//
//	await30Seconds(func() bool {
//		var prmContainerEACL client.PrmContainerEACL
//		prmContainerEACL.SetContainer(containerID)
//		r, err := cli.ContainerEACL(ctx, prmContainerEACL)
//		if err != nil {
//			return false
//		}
//		expected, err := table.Marshal()
//		fmt.Println("expected marshal error ", err)
//		got, err := r.Table().Marshal()
//		fmt.Println("Table marshal error ", err)
//		return bytes.Equal(expected, got)
//	})
//	return nil
//}
func await30Seconds(f func() bool) {
	for i := 1; i <= 30; i++ {
		if f() {
			return
		}

		time.Sleep(time.Second)
	}
	log.Fatal("timeout")
}
// @title           Greenfinch NeoFS RESTful API
// @version         0.1
// @description     This API serves as a route to communicate with your containers via HTTP/REST. You will need to have created a container already. This script will help you do this.
// @termsOfService  See license

// @contact.name   Alex Walker
// @contact.url    @configwizard on Discord

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:9000
// @BasePath  /api/v1
func main() {

	wd, _ := os.Getwd()
	fmt.Println("pwd", wd)
	flag.Usage = func() {
		_, _ = fmt.Fprintf(os.Stderr, usage)
		flag.PrintDefaults()
	}
	flag.Parse()

	/*
		1. make a container with the key of the accessor (browser user)
		2. now start an api with the server's key
	 */
	////
	//var containerOwnerID *owner.ID
	//var containerOwnerClient *client.Client
	//var containerOwnerPrivateKey keys.PrivateKey
	//if *cnt {
	//	//First obtain client credentials: private key of request owner
	//	rawPrivateKey, err := keys.NewPrivateKeyFromHex(os.Getenv("PRIVATE_KEY"))
	//	if err != nil {
	//		log.Fatal("can't read credentials:", err)
	//	}
	//	containerOwnerPrivateKey = keys.PrivateKey{PrivateKey: rawPrivateKey.PrivateKey}
	//	rawContainerOwnerPrivateKeyPublicKey, _ := containerOwnerPrivateKey.PublicKey().MarshalJSON()
	//	containerOwnerID = owner.NewIDFromPublicKey((*ecdsa.PublicKey)(containerOwnerPrivateKey.PublicKey()))
	//	fmt.Println("rawContainerOwnerPrivateKeyPublicKey ", string(rawContainerOwnerPrivateKeyPublicKey)) // this is the public key i am using in javascript
	//	//THE SERVER SHOULD OWN THE CONTAINER ?? THEORY 0.1
	//	containerOwnerClient, err = createClient(&rawPrivateKey.PrivateKey)
	//	if err != nil {
	//		log.Fatal("err ", err)
	//	}
	//}


	//First obtain client credentials: private key of request owner
	apiPrivateKey, err := wal.GetCredentialsFromPath(*walletPath, "", *password)
	if err != nil {
		log.Fatal("can't read credentials:", err)
	}
	fmt.Println(apiPrivateKey)
	w := wal.GetWalletFromPrivateKey(apiPrivateKey)
	log.Println("using account ", w.Address)

	ctx := context.Background()

	//THIS ONLY WORKS IF THE CONTAINER OWNER IS THE CLIENT KEY
	//if *cnt {
	//
	//	//1. the container owner needs to create a container to work on:
	//	containerID, err := createProtectedContainer(ctx, containerOwnerClient, containerOwnerID)
	//	if err != nil {
	//		log.Fatal("err ", err)
	//	}
	//	//2. Now the container owner needs to protect the container from undesirables
	//	if err := setRestrictedContainerAccess(ctx, containerOwnerClient, containerID); err != nil {
	//		log.Fatal("err ", err)
	//	}
	//	fmt.Println("created container id ", containerID)
	//	os.Exit(0)
	//}
	//
	//if *obj {
	//	apiOwnerPrivateKey := keys.PrivateKey{PrivateKey: *apiPrivateKey}
	//	if *containerID == "" {
	//		log.Fatal("to upload an object you must provide a container id")
	//	}
	//	cntID := cid.ID{}
	//	cntID.Parse(*containerID)
	//
	//	apiKeyOwner := owner.NewIDFromPublicKey((*ecdsa.PublicKey)(w.PrivateKey().PublicKey()))
	//	//should the owner of the object be the server? Is that necessary?
	//	//if you want to use a session token
	//	putSession, err := client2.CreateSessionWithObjectPutContext(ctx, apiClient, apiKeyOwner, cntID, utils.GetHelperTokenExpiry(ctx, apiClient), apiPrivateKey)
	//	if err != nil {
	//		log.Fatal(err)
	//	}
	//	//bearer token
	//	table := tokens.PUTAllowDenyOthersEACL(cntID, apiOwnerPrivateKey.PublicKey()) //&apiPrivateKey.PublicKey
	//
	//	bearerToken := token.NewBearerToken()
	//	bearerToken.SetLifetime(utils.GetHelperTokenExpiry(ctx, apiClient), 0, 0)
	//	bearerToken.SetEACLTable(&table)
	//	bearerToken.SetOwner(apiKeyOwner)
	//
	//	// Step 4. Sign bearer token
	//	// If remote signer is a program written in Go, it can use `bearer.Sign()`
	//	// Otherwise signer should sign stable marshalled binary message
	//	v2Bearer := bearerToken.ToV2()
	//	binaryData, _ := v2Bearer.GetBody().StableMarshal(nil)
	//	h := sha512.Sum512(binaryData)
	//	x, y, err := ecdsa.Sign(rand.Reader, &containerOwnerPrivateKey.PrivateKey, h[:])
	//	if err != nil {
	//		log.Fatal("signing errror", err)
	//	}
	//	signatureData := elliptic.Marshal(elliptic.P256(), x, y)
	//	containerOwnerPublicKeyBytes := containerOwnerPrivateKey.PublicKey().Bytes()
	//	v2signature := new(refs.Signature)
	//	v2signature.SetScheme(refs.ECDSA_SHA512)
	//	v2signature.SetSign(signatureData)
	//	v2signature.SetKey(containerOwnerPublicKeyBytes)
	//
	//	v2Bearer.SetSignature(v2signature)
	//	bearerToken = token.NewBearerTokenFromV2(v2Bearer)
	//
	//	var objectID oid.ID
	//	o := object.New()
	//	o.SetContainerID(&cntID)
	//	o.SetOwnerID(apiKeyOwner)
	//
	//	objWriter, err := apiClient.ObjectPutInit(ctx, client.PrmObjectPutInit{})
	//	if putSession != nil {
	//		objWriter.WithinSession(*putSession)
	//	}
	//	//var bearerToken token.BearerToken
	//	if &bearerToken != nil {
	//		objWriter.WithBearerToken(*bearerToken)
	//	}
	//	if !objWriter.WriteHeader(*o) {
	//		log.Fatal(err)
	//	}
	//	objWriter.WritePayloadChunk([]byte("Hello World"))
	//	res, err := objWriter.Close()
	//	if err != nil {
	//		log.Fatal(err)
	//	}
	//	res.ReadStoredObjectID(&objectID)
	//	fmt.Println("successfully stored object ", objectID.String(), " in container ", cntID.String())
	//	os.Exit(0)
	//}

	// the above will have been done by the user, out of band
	r := chi.NewRouter()
	r.Use(middleware.Logger)
	cors := cors.New(cors.Options{
		AllowedOrigins:   []string{"*"},
		// AllowOriginFunc:  func(r *http.Request, origin string) bool { return true },
		AllowedMethods:   []string{"HEAD", "GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"*"}, //"Accept", "Authorization", "Content-Type", "X-CSRF-Token", "publicKey", "x-r", "x-s"
		ExposedHeaders:   []string{"*"},
		AllowCredentials: true, //will be required for api key access management
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	})
	serverPrivateKey := keys.PrivateKey{PrivateKey: apiPrivateKey}
	rawServerContainerPublicKey, _ := serverPrivateKey.PublicKey().MarshalJSON()

	cfg, err := config.ReadConfig("cfg", *configLocation)
	if err != nil {
		log.Fatal("error reading config ", err)
	}

	pl, err := pool.GetPool(ctx, apiPrivateKey, cfg.Peers)
	if err != nil {
		log.Fatal("error could not instantiate pool", err)
	}
	//rawContainerOwnerPrivateKeyPublicKey := apiPrivateKey.PublicKey
	fmt.Println("using public key ", rawServerContainerPublicKey)
	r.Use(cors.Handler)

	//FileServer(r) //static file serving frontend
	//fs := http.FileServer(http.Dir("./swagger"))
	//r.Handle("/client", fs)
	//fs := http.FileServer(http.Dir("dist"))
	//r.Handle("/swagger/*", http.StripPrefix("/swagger/", fs))
	//r.Handle("/swagger/", http.StripPrefix("/swagger/", fs))
	r.Route("/api/v1/bearer", func(r chi.Router) {
		r.Use(WalletCtx)
		//ok so this endpoint is requesting a new bearer token to sign
		r.Get("/{containerId}", tokens.UnsignedBearerToken(&serverPrivateKey, *pl))
	})
	r.Route("/api/v1/container", func(r chi.Router) {
		r.Use(WalletCtx)
		r.Get("/", func(w http.ResponseWriter, r *http.Request) {
			w.Write([]byte("endpoint not ready"))
			return
		})
		//r.Head("/{containerId}", containers.GetContainer(apiClient))
		//r.Post("/{containerId}", objects.GetObjectHead(apiClient))
		//r.Delete("/{containerId}", objects.GetObjectHead(apiClient))
	})
	r.Route("/api/v1/object", func(r chi.Router) {
		r.Use(WalletCtx)
		r.Head("/{containerId}/{objectId}", objects.GetObjectHead(&serverPrivateKey, *pl))
		r.Get("/data/{containerId}/{objectId}", objects.GetObjectHead(&serverPrivateKey, *pl))
		r.Get("/{containerId}", objects.ListObjectsInContainer(&serverPrivateKey, *pl))
		r.Delete("/{containerId}/{objectId}", objects.DeleteObject(&serverPrivateKey, *pl))
		r.Get("/{containerId}/{objectId}", objects.GetObject(&serverPrivateKey, *pl))
		r.Post("/{containerId}", objects.UploadObject(&serverPrivateKey, *pl))

	})
	swaggerFs := http.FileServer(http.Dir("swagger"))
	r.Handle("/swagger/", http.StripPrefix("/swagger/", swaggerFs))
	clientFs := http.FileServer(http.Dir("client"))
	r.Handle("/*", clientFs)
	log.Println("about to listen and server")
	err = http.ListenAndServe(":9000", r)
	if err != nil {
		log.Fatal("error ", err)
	}
}
// FileServer is serving static files.
//func DocServer(router *chi.Mux) {
//	root := "./api"
//	fs := http.FileServer(http.Dir(root))
//
//	router.Get("/swagger", func(w http.ResponseWriter, r *http.Request) {
//		st, err := os.Stat(root + r.RequestURI)
//		fmt.Println("stat", st, err)
//		if os.IsNotExist(err) {
//			http.StripPrefix(r.RequestURI, fs).ServeHTTP(w, r)
//		} else {
//			http.StripPrefix(r.RequestURI, fs).ServeHTTP(w, r)
//		}
//	})
//}
// FileServer is serving static files.
func FileServer(router *chi.Mux) {
	root := "./client"
	fs := http.FileServer(http.Dir(root))

	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		if _, err := os.Stat(root + r.RequestURI); os.IsNotExist(err) {
			http.StripPrefix(r.RequestURI, fs).ServeHTTP(w, r)
		} else {
			fs.ServeHTTP(w, r)
		}
	})
}
func WalletCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		publicKey := r.Header.Get("publicKey")
		stringR := r.Header.Get("X-r")
		stringS := r.Header.Get("X-s")
		ctx := context.WithValue(r.Context(), "publicKey", publicKey)
		ctx = context.WithValue(ctx, "stringR", stringR)
		ctx = context.WithValue(ctx, "stringS", stringS)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

