package main

import (
	"context"
	"crypto/ecdsa"
	_ "embed"
	"errors"
	"flag"
	"fmt"
	_ "github.com/configwizard/greenfinch-api/api/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/configwizard/greenfinch-api/api/objects"
	"github.com/configwizard/greenfinch-api/api/pkg/tokens"
	"github.com/configwizard/greenfinch-api/api/pkg/utils"
	wal "github.com/configwizard/greenfinch-api/api/pkg/wallet"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	"github.com/nspcc-dev/neo-go/cli/flags"
	"github.com/nspcc-dev/neo-go/pkg/crypto/keys"
	"github.com/nspcc-dev/neo-go/pkg/util"
	"github.com/nspcc-dev/neo-go/pkg/wallet"
	"log"
	"net/http"
	"os"
)

const usage = `Example

$ ./uploadObjects -wallets ../sample_wallets/wallet.json
password is password
`


var (
	walletPath = flag.String("wallet", os.Getenv("WALLET_PATH"), "path to JSON wallets file")
	configLocation = flag.String("config", "./", "wallet password")
	password = flag.String("password", os.Getenv("WALLET_KEY"), "wallet password")
)

func GetCredentialsFromPath(path, address, password string) (*ecdsa.PrivateKey, error) {
	w, err := wallet.NewWalletFromFile(path)
	if err != nil {
		return nil, fmt.Errorf("can't read the wallets: %walletPath", err)
	}

	return getKeyFromWallet(w, address, password)
}
// getKeyFromWallet fetches private key from neo-go wallets structure
func getKeyFromWallet(w *wallet.Wallet, addrStr, password string) (*ecdsa.PrivateKey, error) {
	var (
		addr util.Uint160
		err  error
	)

	if addrStr == "" {
		addr = w.GetChangeAddress()
	} else {
		addr, err = flags.ParseAddress(addrStr)
		if err != nil {
			return nil, fmt.Errorf("invalid wallets address %s: %w", addrStr, err)
		}
	}

	acc := w.GetAccount(addr)
	if acc == nil {
		return nil, fmt.Errorf("invalid wallets address %s: %w", addrStr, err)
	}

	if err := acc.Decrypt(password, keys.NEP2ScryptParams()); err != nil {
		return nil, errors.New("[decrypt] invalid password - " + err.Error())

	}

	return &acc.PrivateKey().PrivateKey, nil
}

// @title           Greenfinch NeoFS RESTful API
// @version         0.1
// @description     This API serves as a route to communicate with your containers via HTTP/REST. You will need to have created a container already. This script will help you do this.
// @termsOfService  See license

// @contact.name   Alex Walker
// @contact.url    @configwizard on Discord

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:9000
// @BasePath  /api/v1
func main() {

	wd, _ := os.Getwd()
	fmt.Println("pwd", wd)
	flag.Usage = func() {
		_, _ = fmt.Fprintf(os.Stderr, usage)
		flag.PrintDefaults()
	}
	flag.Parse()


	//First obtain client credentials: private key of request owner
	apiPrivateKey, err := wal.GetCredentialsFromPath(*walletPath, "", *password)
	if err != nil {
		log.Fatal("can't read credentials:", err)
	}
	fmt.Println(apiPrivateKey)
	w := wal.GetWalletFromPrivateKey(apiPrivateKey)
	log.Println("using account ", w.Address)

	// the above will have been done by the user, out of band
	r := chi.NewRouter()
	r.Use(middleware.Logger)
	cors := cors.New(cors.Options{
		AllowedOrigins:   []string{"*"},
		// AllowOriginFunc:  func(r *http.Request, origin string) bool { return true },
		AllowedMethods:   []string{"HEAD", "GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"*"}, //"Accept", "Authorization", "Content-Type", "X-CSRF-Token", "publicKey", "x-r", "x-s"
		ExposedHeaders:   []string{"*"},
		AllowCredentials: true, //will be required for api key access management
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	})
	//the server's private key could/should be ephemeral
	serverPrivateKey := keys.PrivateKey{PrivateKey: apiPrivateKey}
	rawServerContainerPublicKey, _ := serverPrivateKey.PublicKey().MarshalJSON()

	fmt.Println("using public key ", rawServerContainerPublicKey)
	r.Use(cors.Handler)

	r.Route("/api/v1/bearer", func(r chi.Router) {
		r.Use(WalletCtx)
		//ok so this endpoint is requesting a new bearer token to sign
		r.Get("/{containerId}", tokens.UnsignedBearerToken(&serverPrivateKey))
	})
	r.Route("/api/v1/container", func(r chi.Router) {
		r.Use(WalletCtx)
		r.Get("/", func(w http.ResponseWriter, r *http.Request) {
			w.Write([]byte("endpoint not ready. Please use Greenfinch (https://greenfinch.app) to manage containers for the time being"))
			return
		})
	})
	r.Route("/api/v1/object", func(r chi.Router) {
		r.Use(WalletCtx)
		r.Head("/{containerId}/{objectId}", objects.GetObjectHead(&serverPrivateKey))
		r.Get("/data/{containerId}/{objectId}", objects.GetObjectHead(&serverPrivateKey))
		r.Get("/{containerId}", objects.ListObjectsInContainer(&serverPrivateKey))
		r.Delete("/{containerId}/{objectId}", objects.DeleteObject(&serverPrivateKey))
		r.Get("/{containerId}/{objectId}", objects.GetObject(&serverPrivateKey))
		r.Post("/{containerId}", objects.UploadObject(&serverPrivateKey))

	})
	clientFs := http.FileServer(http.Dir("client"))
	r.Handle("/*", clientFs)
	log.Println("about to listen and server")
	err = http.ListenAndServe(":"+os.Getenv("PORT"), r)
	if err != nil {
		log.Fatal("error ", err)
	}
}

func WalletCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		publicKey := r.Header.Get("publicKey")
		stringR := r.Header.Get("X-r")
		stringS := r.Header.Get("X-s")
		network := r.Header.Get("X-network")
		fmt.Println("network ", network)
		if network == "" {
			network = string(utils.Testnet) //default to testnet
		}
		if utils.Network(network) != utils.Mainnet && utils.Network(network) != utils.Testnet {
			err := errors.New("no network named " + network)
			log.Println("error could not get network", err)
			http.Error(w, err.Error(), 400)
			return
		}
		fmt.Println("network ", network)
		ctx := context.WithValue(r.Context(), "publicKey", publicKey)
		ctx = context.WithValue(ctx, "network", network)
		ctx = context.WithValue(ctx, "stringR", stringR)
		ctx = context.WithValue(ctx, "stringS", stringS)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

